From 4fa3c13af8917020db75ce04edb4a95a91b45ed0 Mon Sep 17 00:00:00 2001
From: Janmm14 <computerjanimaus@yahoo.de>
Date: Sun, 21 Feb 2016 22:01:12 +0100
Subject: Performance, log sanity: No exception on invalid packet order, just
 disconnect and one line notice.

---
 .../net/md_5/bungee/connection/InitialHandler.java | 39 ++++++++++++++++++----
 1 file changed, 33 insertions(+), 6 deletions(-)

diff --git a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
index 41c15da..0db52b3 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
@@ -6,7 +6,6 @@ import java.math.BigInteger;
 import java.net.InetSocketAddress;
 import java.net.URLEncoder;
 import java.security.MessageDigest;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
 import java.util.logging.Level;
@@ -182,10 +181,30 @@ public class InitialHandler extends PacketHandler implements PendingConnection
         return pos == -1 ? str : str.substring( 0, pos );
     }
 
+    /**
+     * <p>Checks whether the current state of this connection equals the expected state.</p>
+     * If states do not fit, this method gives a log information and disconnects without delay.
+     *
+     * @param expectedState the state this InitialHandler has to be in
+     * @return {@code false} if the states do not equal and whether the handling of the packet should be <b>aborted</b>
+     */
+    private boolean checkState(State expectedState)
+    {
+        if (thisState != expectedState)
+        {
+            bungee.getLogger().log( Level.WARNING, "{0} Not expecting {1}", new Object[]{ this, expectedState } );
+            disconnect( "Not expecting " + thisState, false );
+            return false;
+        }
+        return true;
+    }
+
     @Override
     public void handle(StatusRequest statusRequest) throws Exception
     {
-        Preconditions.checkState( thisState == State.STATUS, "Not expecting STATUS" );
+        if (!checkState( State.STATUS )) {
+            return;
+        }
 
         ServerInfo forced = AbstractReconnectHandler.getForcedHost( this );
         final String motd = ( forced != null ) ? forced.getMotd() : listener.getMotd();
@@ -225,7 +244,9 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(PingPacket ping) throws Exception
     {
-        Preconditions.checkState( thisState == State.PING, "Not expecting PING" );
+        if (!checkState( State.PING )) {
+            return;
+        }
         unsafe.sendPacket( ping );
         disconnect( "" );
     }
@@ -233,7 +254,9 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(Handshake handshake) throws Exception
     {
-        Preconditions.checkState( thisState == State.HANDSHAKE, "Not expecting HANDSHAKE" );
+        if (!checkState( State.HANDSHAKE )) {
+            return;
+        }
         this.handshake = handshake;
         ch.setVersion( handshake.getProtocolVersion() );
 
@@ -297,7 +320,9 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(LoginRequest loginRequest) throws Exception
     {
-        Preconditions.checkState( thisState == State.USERNAME, "Not expecting USERNAME" );
+        if (!checkState( State.USERNAME )) {
+            return;
+        }
         this.loginRequest = loginRequest;
 
         if ( !Protocol.supportedVersions.contains( handshake.getProtocolVersion() ) )
@@ -360,7 +385,9 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(final EncryptionResponse encryptResponse) throws Exception
     {
-        Preconditions.checkState( thisState == State.ENCRYPT, "Not expecting ENCRYPT" );
+        if (!checkState( State.ENCRYPT )) {
+            return;
+        }
 
         SecretKey sharedKey = EncryptionUtil.getSecret( encryptResponse, request );
         BungeeCipher decrypt = EncryptionUtil.getCipher( false, sharedKey );
-- 
1.9.5.msysgit.0

