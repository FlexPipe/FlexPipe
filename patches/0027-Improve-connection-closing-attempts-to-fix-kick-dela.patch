From b1b837f852a7ef7a8adef08d1e0fd2e851335263 Mon Sep 17 00:00:00 2001
From: Janmm14 <computerjanimaus@yahoo.de>
Date: Mon, 29 Feb 2016 20:14:29 +0100
Subject: Improve connection closing, attempts to fix kick delay.

Adapted from https://github.com/SpigotMC/BungeeCord/pull/1706 by @kamcio96, he claimed that these channel closing changes are removing the need of delayed kick packets. I can confirm this (at login state) on a no-latency and low-latency connection (<1ms; ~16ms), high-latency connection was not tested, but it should work on these too.
---
 .../net/md_5/bungee/connection/InitialHandler.java | 358 ++++++++++-----------
 1 file changed, 168 insertions(+), 190 deletions(-)

diff --git a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
index 1075997..5fddbab 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
@@ -6,6 +6,7 @@ import java.math.BigInteger;
 import java.net.InetSocketAddress;
 import java.net.URLEncoder;
 import java.security.MessageDigest;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
 import java.util.logging.Level;
@@ -145,33 +146,38 @@ public class InitialHandler extends PacketHandler implements PendingConnection
         ServerPing legacy = new ServerPing( new ServerPing.Protocol( bungee.getName() + " " + bungee.getGameVersion(), bungee.getProtocolVersion() ),
                 new ServerPing.Players( listener.getMaxPlayers(), bungee.getOnlineCount(), null ), listener.getMotd(), (Favicon) null );
 
-        Callback<ProxyPingEvent> callback = (result, error) -> {
-            if ( ch.isClosed() )
+        Callback<ProxyPingEvent> callback = new Callback<ProxyPingEvent>()
+        {
+            @Override
+            public void done(ProxyPingEvent result, Throwable error)
             {
-                return;
-            }
+                if ( ch.isClosed() )
+                {
+                    return;
+                }
 
-            ServerPing legacy1 = result.getResponse();
-            String kickMessage;
+                ServerPing legacy = result.getResponse();
+                String kickMessage;
 
-            if ( v1_5 )
-            {
-                kickMessage = ChatColor.DARK_BLUE
-                        + "\00" + 127
-                        + '\00' + legacy1.getVersion().getName()
-                        + '\00' + getFirstLine( legacy1.getDescription() )
-                        + '\00' + legacy1.getPlayers().getOnline()
-                        + '\00' + legacy1.getPlayers().getMax();
-            } else
-            {
-                // Clients <= 1.3 don't support colored motds because the color char is used as delimiter
-                kickMessage = ChatColor.stripColor( getFirstLine( legacy1.getDescription() ) )
-                        + '\u00a7' + legacy1.getPlayers().getOnline()
-                        + '\u00a7' + legacy1.getPlayers().getMax();
-            }
+                if ( v1_5 )
+                {
+                    kickMessage = ChatColor.DARK_BLUE
+                            + "\00" + 127
+                            + '\00' + legacy.getVersion().getName()
+                            + '\00' + getFirstLine( legacy.getDescription() )
+                            + '\00' + legacy.getPlayers().getOnline()
+                            + '\00' + legacy.getPlayers().getMax();
+                } else
+                {
+                    // Clients <= 1.3 don't support colored motds because the color char is used as delimiter
+                    kickMessage = ChatColor.stripColor( getFirstLine( legacy.getDescription() ) )
+                            + '\u00a7' + legacy.getPlayers().getOnline()
+                            + '\u00a7' + legacy.getPlayers().getMax();
+                }
 
-            ch.getHandle().writeAndFlush( kickMessage );
-            ch.close();
+                ch.getHandle().writeAndFlush( kickMessage );
+                ch.close();
+            }
         };
 
         bungee.getPluginManager().callEvent( new ProxyPingEvent( this, legacy, callback ) );
@@ -183,49 +189,38 @@ public class InitialHandler extends PacketHandler implements PendingConnection
         return pos == -1 ? str : str.substring( 0, pos );
     }
 
-    /**
-     * <p>Checks whether the current state of this connection equals the expected state.</p>
-     * If states do not fit, this method gives a log information and disconnects without delay.
-     *
-     * @param expectedState the state this InitialHandler has to be in
-     * @return {@code false} if the states do not equal and whether the handling of the packet should be <b>aborted</b>
-     */
-    private boolean checkState(State expectedState)
-    {
-        if (thisState != expectedState)
-        {
-            bungee.getLogger().log( Level.WARNING, "{0} Not expecting {1}", new Object[]{ this, expectedState } );
-            disconnect( "Not expecting " + thisState, false );
-            return false;
-        }
-        return true;
-    }
-
     @Override
     public void handle(StatusRequest statusRequest) throws Exception
     {
-        if ( !checkState( State.STATUS ) )
-        {
-            return;
-        }
+        Preconditions.checkState( thisState == State.STATUS, "Not expecting STATUS" );
 
         ServerInfo forced = AbstractReconnectHandler.getForcedHost( this );
         final String motd = ( forced != null ) ? forced.getMotd() : listener.getMotd();
 
-        Callback<ServerPing> pingBack = (result, error) -> {
-            if ( error != null )
+        Callback<ServerPing> pingBack = new Callback<ServerPing>()
+        {
+            @Override
+            public void done(ServerPing result, Throwable error)
             {
-                result = new ServerPing();
-                result.setDescription( bungee.getTranslation( "ping_cannot_connect" ) );
-                bungee.getLogger().log( Level.WARNING, "Error pinging remote server", error );
-            }
+                if ( error != null )
+                {
+                    result = new ServerPing();
+                    result.setDescription( bungee.getTranslation( "ping_cannot_connect" ) );
+                    bungee.getLogger().log( Level.WARNING, "Error pinging remote server", error );
+                }
 
-            Callback<ProxyPingEvent> callback = (pingResult, error1) -> {
-                Gson gson = handshake.getProtocolVersion() == ProtocolConstants.MINECRAFT_1_7_2 ? BungeeCord.getInstance().gsonLegacy : BungeeCord.getInstance().gson;
-                unsafe.sendPacket( new StatusResponse( gson.toJson( pingResult.getResponse() ) ) );
-            };
+                Callback<ProxyPingEvent> callback = new Callback<ProxyPingEvent>()
+                {
+                    @Override
+                    public void done(ProxyPingEvent pingResult, Throwable error)
+                    {
+                        Gson gson = handshake.getProtocolVersion() == ProtocolConstants.MINECRAFT_1_7_2 ? BungeeCord.getInstance().gsonLegacy : BungeeCord.getInstance().gson;
+                        unsafe.sendPacket( new StatusResponse( gson.toJson( pingResult.getResponse() ) ) );
+                    }
+                };
 
-            bungee.getPluginManager().callEvent( new ProxyPingEvent( InitialHandler.this, result, callback ) );
+                bungee.getPluginManager().callEvent( new ProxyPingEvent( InitialHandler.this, result, callback ) );
+            }
         };
 
         if ( forced != null && listener.isPingPassthrough() )
@@ -247,10 +242,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(PingPacket ping) throws Exception
     {
-        if ( !checkState( State.PING ) )
-        {
-            return;
-        }
+        Preconditions.checkState( thisState == State.PING, "Not expecting PING" );
         unsafe.sendPacket( ping );
         disconnect( "" );
     }
@@ -258,10 +250,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(Handshake handshake) throws Exception
     {
-        if ( !checkState( State.HANDSHAKE ) )
-        {
-            return;
-        }
+        Preconditions.checkState( thisState == State.HANDSHAKE, "Not expecting HANDSHAKE" );
         this.handshake = handshake;
         ch.setVersion( handshake.getProtocolVersion() );
 
@@ -275,8 +264,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
             thisState = State.USERNAME;
             // setting protocol to login so we can send the kick message which is actually supported by the minecraft client after it sent the handshake
             ch.setProtocol( Protocol.LOGIN );
-            // do not wait for kick because its better to free up resources on bot attacks earlier than being sure the kick message is shown correctly.
-            disconnect( bungee.getTranslation( "join_throttle_kick", TimeUnit.MILLISECONDS.toSeconds( BungeeCord.getInstance().getConfig().getThrottle() ) ), false );
+            disconnect( bungee.getTranslation( "join_throttle_kick", TimeUnit.MILLISECONDS.toSeconds( BungeeCord.getInstance().getConfig().getThrottle() ) ) );
             // this stops the also sent login request packet to be handled
             thisJoinThrottled = true;
             return;
@@ -341,10 +329,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
             ch.close();
             return;
         }
-        if ( !checkState( State.USERNAME ) )
-        {
-            return;
-        }
+        Preconditions.checkState( thisState == State.USERNAME, "Not expecting USERNAME" );
         this.loginRequest = loginRequest;
 
         if ( !Protocol.supportedVersions.contains( handshake.getProtocolVersion() ) )
@@ -380,24 +365,30 @@ public class InitialHandler extends PacketHandler implements PendingConnection
             return;
         }
 
-        Callback<PreLoginEvent> callback = (result, error) -> {
-            if ( result.isCancelled() )
-            {
-                disconnect( result.getCancelReason() );
-                return;
-            }
-            if ( ch.isClosed() )
-            {
-                return;
-            }
-            if ( onlineMode )
-            {
-                unsafe().sendPacket( request = EncryptionUtil.encryptRequest() );
-            } else
+        Callback<PreLoginEvent> callback = new Callback<PreLoginEvent>()
+        {
+
+            @Override
+            public void done(PreLoginEvent result, Throwable error)
             {
-                finish();
+                if ( result.isCancelled() )
+                {
+                    disconnect( result.getCancelReason() );
+                    return;
+                }
+                if ( ch.isClosed() )
+                {
+                    return;
+                }
+                if ( onlineMode )
+                {
+                    unsafe().sendPacket( request = EncryptionUtil.encryptRequest() );
+                } else
+                {
+                    finish();
+                }
+                thisState = State.ENCRYPT;
             }
-            thisState = State.ENCRYPT;
         };
 
         // fire pre login event
@@ -407,10 +398,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(final EncryptionResponse encryptResponse) throws Exception
     {
-        if ( !checkState( State.ENCRYPT ) )
-        {
-            return;
-        }
+        Preconditions.checkState( thisState == State.ENCRYPT, "Not expecting ENCRYPT" );
 
         SecretKey sharedKey = EncryptionUtil.getSecret( encryptResponse, request );
         BungeeCipher decrypt = EncryptionUtil.getCipher( false, sharedKey );
@@ -432,22 +420,27 @@ public class InitialHandler extends PacketHandler implements PendingConnection
 
         String authURL = "https://sessionserver.mojang.com/session/minecraft/hasJoined?username=" + encName + "&serverId=" + encodedHash;
 
-        Callback<String> handler = (result, error) -> {
-            if ( error == null )
+        Callback<String> handler = new Callback<String>()
+        {
+            @Override
+            public void done(String result, Throwable error)
             {
-                LoginResult obj = BungeeCord.getInstance().gson.fromJson( result, LoginResult.class );
-                if ( obj != null )
+                if ( error == null )
                 {
-                    loginProfile = obj;
-                    uniqueId = Util.getUUID( obj.getId() );
-                    finish();
-                    return;
+                    LoginResult obj = BungeeCord.getInstance().gson.fromJson( result, LoginResult.class );
+                    if ( obj != null )
+                    {
+                        loginProfile = obj;
+                        uniqueId = Util.getUUID( obj.getId() );
+                        finish();
+                        return;
+                    }
+                    disconnect( "Not authenticated with Minecraft.net" );
+                } else
+                {
+                    disconnect( bungee.getTranslation( "mojang_fail" ) );
+                    bungee.getLogger().log( Level.SEVERE, "Error authenticating " + getName() + " with minecraft.net", error );
                 }
-                disconnect( "Not authenticated with Minecraft.net" );
-            } else
-            {
-                disconnect( bungee.getTranslation( "mojang_fail" ) );
-                bungee.getLogger().log( Level.SEVERE, "Error authenticating " + getName() + " with minecraft.net", error );
             }
         };
 
@@ -492,53 +485,63 @@ public class InitialHandler extends PacketHandler implements PendingConnection
             uniqueId = offlineId;
         }
 
-        Callback<LoginEvent> complete = (result, error) -> {
-            if ( result.isCancelled() )
-            {
-                disconnect( result.getCancelReason() );
-                return;
-            }
-            if ( ch.isClosed() )
+        Callback<LoginEvent> complete = new Callback<LoginEvent>()
+        {
+            @Override
+            public void done(LoginEvent result, Throwable error)
             {
-                return;
-            }
-
-            ch.getHandle().eventLoop().execute( () -> {
-                if ( ch.getHandle().isActive() )
+                if ( result.isCancelled() )
                 {
-                    UserConnection userCon = new UserConnection( bungee, ch, getName(), InitialHandler.this );
-                    userCon.setCompressionThreshold( BungeeCord.getInstance().config.getCompressionThreshold() );
-                    userCon.init();
-
-                    if ( getVersion() >= ProtocolConstants.MINECRAFT_1_7_6 )
-                    {
-                        unsafe.sendPacket( new LoginSuccess( getUniqueId().toString(), getName() ) ); // With dashes in between
-                    } else
-                    {
-                        unsafe.sendPacket( new LoginSuccess( getUUID(), getName() ) ); // Without dashes, for older clients.
-                    }
-                    ch.setProtocol( Protocol.GAME );
+                    disconnect( result.getCancelReason() );
+                    return;
+                }
+                if ( ch.isClosed() )
+                {
+                    return;
+                }
 
-                    ch.getHandle().pipeline().get( HandlerBoss.class ).setHandler( new UpstreamBridge( bungee, userCon ) );
-                    bungee.getPluginManager().callEvent( new PostLoginEvent( userCon ) );
-                    ServerInfo server;
-                    if ( bungee.getReconnectHandler() != null )
-                    {
-                        server = bungee.getReconnectHandler().getServer( userCon );
-                    } else
-                    {
-                        server = AbstractReconnectHandler.getForcedHost( InitialHandler.this );
-                    }
-                    if ( server == null )
+                ch.getHandle().eventLoop().execute( new Runnable()
+                {
+                    @Override
+                    public void run()
                     {
-                        server = bungee.getServerInfo( listener.getDefaultServer() );
+                        if ( ch.getHandle().isActive() )
+                        {
+                            UserConnection userCon = new UserConnection( bungee, ch, getName(), InitialHandler.this );
+                            userCon.setCompressionThreshold( BungeeCord.getInstance().config.getCompressionThreshold() );
+                            userCon.init();
+
+                            if ( getVersion() >= ProtocolConstants.MINECRAFT_1_7_6 )
+                            {
+                                unsafe.sendPacket( new LoginSuccess( getUniqueId().toString(), getName() ) ); // With dashes in between
+                            } else
+                            {
+                                unsafe.sendPacket( new LoginSuccess( getUUID(), getName() ) ); // Without dashes, for older clients.
+                            }
+                            ch.setProtocol( Protocol.GAME );
+
+                            ch.getHandle().pipeline().get( HandlerBoss.class ).setHandler( new UpstreamBridge( bungee, userCon ) );
+                            bungee.getPluginManager().callEvent( new PostLoginEvent( userCon ) );
+                            ServerInfo server;
+                            if ( bungee.getReconnectHandler() != null )
+                            {
+                                server = bungee.getReconnectHandler().getServer( userCon );
+                            } else
+                            {
+                                server = AbstractReconnectHandler.getForcedHost( InitialHandler.this );
+                            }
+                            if ( server == null )
+                            {
+                                server = bungee.getServerInfo( listener.getDefaultServer() );
+                            }
+
+                            userCon.connect( server, null, true );
+
+                            thisState = State.FINISHED;
+                        }
                     }
-
-                    userCon.connect( server, null, true );
-
-                    thisState = State.FINISHED;
-                }
-            } );
+                } );
+            }
         };
 
         // fire login event
@@ -548,38 +551,32 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void disconnect(String reason)
     {
-        disconnect( TextComponent.fromLegacyText( reason ), true );
-    }
-
-    @Override
-    public void disconnect(String reason, boolean wait)
-    {
-        disconnect( TextComponent.fromLegacyText( reason ), wait );
+        disconnect( TextComponent.fromLegacyText( reason ) );
     }
 
     @Override
     public void disconnect(final BaseComponent... reason)
     {
-        disconnect( reason, true );
-    }
-
-    @Override
-    public void disconnect(final BaseComponent[] reason, boolean wait)
-    {
         if ( !ch.isClosed() )
         {
-            if ( wait )
-            {
-                // Why do we have to delay this you might ask? Well the simple reason is MOJANG.
-                // Despite many a bug report posted, ever since the 1.7 protocol rewrite, the client STILL has a race condition upon switching protocols.
-                // As such, despite the protocol switch packets already having been sent, there is the possibility of a client side exception
-                // To help combat this we will wait half a second before actually sending the disconnected packet so that whoever is on the other
-                // end has a somewhat better chance of receiving the proper packet.
-                ch.getHandle().eventLoop().schedule( ( Runnable ) () -> InitialHandler.this.disconnect0( reason ), 500, TimeUnit.MILLISECONDS );
-            } else
+            // Why do we have to delay this you might ask? Well the simple reason is MOJANG.
+            // Despite many a bug report posted, ever since the 1.7 protocol rewrite, the client STILL has a race condition upon switching protocols.
+            // As such, despite the protocol switch packets already having been sent, there is the possibility of a client side exception
+            // To help combat this we will wait half a second before actually sending the disconnected packet so that whoever is on the other
+            // end has a somewhat better chance of receiving the proper packet.
+            ch.getHandle().eventLoop().schedule( new Runnable()
             {
-                disconnect0( reason );
-            }
+
+                @Override
+                public void run()
+                {
+                    if ( thisState != State.STATUS && thisState != State.PING )
+                    {
+                        unsafe().sendPacket( new Kick( ComponentSerializer.toString( reason ) ) );
+                    }
+                    ch.close();
+                }
+            }, 500, TimeUnit.MILLISECONDS );
         }
     }
 
@@ -589,26 +586,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
         disconnect( new BaseComponent[]
         {
             reason
-        },
-        true );
-    }
-
-    @Override
-    public void disconnect(BaseComponent reason, boolean wait)
-    {
-        disconnect( new BaseComponent[]
-            {
-                reason
-            },
-            wait );
-    }
-
-    private void disconnect0(BaseComponent... reason) {
-        if ( thisState != State.STATUS && thisState != State.PING )
-        {
-            unsafe().sendPacket( new Kick( ComponentSerializer.toString( reason ) ) );
-        }
-        ch.close();
+        } );
     }
 
     @Override
@@ -653,7 +631,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public String getUUID()
     {
-        return Util.getMojangUUID( uniqueId );
+        return uniqueId.toString().replaceAll( "-", "" );
     }
 
     @Override
-- 
1.9.5.msysgit.0

